# -*- coding: utf-8-unix -*-
#+STARTUP: showall indent

* Pug - a /Pug programming language/ interpreter

The ~pug~ is an interpreter of /The Pug programming language/.\\
(that is *a toy language* for now)

The ~pug~ interpreter is also a sample application powered by /CPARSEC3/
library.

#+begin_quote
- *NOTE* /The Pug programming language/ is not /Pug(Jade)/. ::
     Though I know there is another language named /Pug(Jade)/,
     this is unrelated to that.\\
     (I didn't know that Jade was renamed to Pug. sigh.)
#+end_quote

* Pug Programming Language

/The Pug programming language/ is :
- A pure functional language.
- Syntax is similar to /Rust/, semantics is similar to /Haskell/.
- A scope of accessible variables is based on *static / lexical scoping*.
- A function is a first class object (i.e. function is an object)
- Function is represented as a *lambda expression*. (lambda abstraction)
- All function is *curried*. (i.e. ~f x y z~ = ~((f x) y) z~)
- Partial *function application* is ofcourse supported.
- there is no special syntax for defining a named function.\\
  Defining a named function is *defining a variable whose value is a lambda*.

- [[file:docs/syntax.md][Syntax]] :: Declaratons, Expressions, Operators syntax.

* How to build
To build the ~Pug~ interpreter, do as follows :
- *NOTE* Suppose that the leading '*$*' is a shell prompt.
- *NOTE* Suppose that the '*#*' follows words are comment.

#+begin_src shell
$ make
#+end_src

* Usage
See the help that appears by the following command.
#+begin_src shell
$ ./bin/pug --help
#+end_src

To run a script, use ~-e SCRIPT~ option:
#+begin_src shell
$ ./bin/pug -e '1 + 2'
> 1 + 2
>> (Add 1 2)
3

#+end_src

#+begin_src shell
$ ./bin/pug -e 'let x = 1; let y = 2; x + y'
> let x = 1; let y = 2; x + y
>> (Seq (Let (Var x) 1) (Seq (Let (Var y) 2) (Add (Var x) (Var y))))
3

#+end_src

* Example

Example: fibonacci function ~fib~
#+begin_src rust
// `fib n` calculates `n`th fibonacci number (n>=0)
let fib = |n| {
  let f = |n a b|
    if n == 0 {
      1
    } else if n == 1 {
      a
    } else {
      f (n-1) (a+b) a
    }
  ;
  f n 1 1;
};
#+end_src

Example: factorial function ~fact~
#+begin_src rust
// `fact x` calculates `x!` (i.e. x * (x-1) * (x-2) * ... * 1)
//
// NOTE: The argument `x` should be `x <= 20`,
//       otherwise calculation overflows.
//       (21! is too large for 64bit integer)
let fact = |x| {
  let f = |x a|
    if x <= 1 {
      a
    } else {
      f (x-1) (x*a)
    }
  ;
  f x 1
};
#+end_src

* Sample code

See also sample code in the [[file:example/][example]] folder.
- [[file:example/fact.txt][factorial function]]
- [[file:example/fib.txt][fibonacci number]]
- [[file:example/list.txt][list and folding functions]]
- [[file:example/lambda_calculus.txt][bool and list (implemented using just lambda expression)]]

