// -*- coding: utf-8-unix -*-

// -----------------------------------------------------------------------
// Bool can be implemented by using just lambda expression.

let False = |_ F| F;
let True  = |T _| T;

// print (True == True);           // true
// print (True == False);          // false
// print (False == True);          // false
// print (False == False);         // true

let and = |p q| p q p;
let or  = |p q| p p q;
let not = |p| p False True;

print (and True True);          // True
print (and True False);         // False
print (and False True);         // False
print (and False False);        // False

print (or True True);           // True
print (or True False);          // True
print (or False True);          // True
print (or False False);         // False

print (not True);               // False
print (not False);              // True

// -----------------------------------------------------------------------
// List can be implemented by using just lambda expression.

let Cons = |x xs| |f| f x xs;
let Nil  = |_| True;
let head = |xs| xs True;
let tail = |xs| xs False;
let null = |xs| xs (|x y| False);

let xs = Cons 1 (Cons 2 (Cons 3 Nil));

print (null xs);                // False
print (null Nil);               // True

print (head xs);                // 1
print (head (tail xs));         // 2
print (head (tail (tail xs)));  // 3
print (tail (tail (tail xs)));  // Nil

// print (null xs true false);     // false
// print (null Nil true false);    // true


// -----------------------------------------------------------------------
// let foldr = |f a xs| (null xs) a (f (head xs) (foldr f a (tail xs)));
// let foldl = |f a xs| (null xs) a (foldl f (f a (head xs)) (tail xs));
//
// NOTE: The above code ought to be okay but currently not.
// This is an issue regarding evaluation strategy of function application.
// (i.e. strict evaluation vs lazy evaluation)

let foldr = |f a xs|
  if null xs == True {
    a
  } else {
    // force strict evaluation of `a` for avoiding stack overflow
    a;
    f (head xs) (foldr f a (tail xs))
  }
;

let foldl = |f a xs|
  if null xs == True {
    a
  } else {
    // force strict evaluation of `a` for avoiding stack overflow
    a;
    foldl f (f a (head xs)) (tail xs)
  }
;

let (+) = |a b| a + b;
let sub = |a b| a - b;

print (foldr (+) 0 xs);         // 6
print (foldl (+) 0 xs);         // 6
print (foldr sub 0 xs);         // 2
print (foldl sub 0 xs);         // -6

// take leading `n` elements from list
let take = |n xs|
  if n <= 0 {
    Nil
  } else {
    Cons (head xs) (take (n-1) (tail xs))
  }
;

// drop leading `n` elements from list
let drop = |n xs|
  if n <= 0 {
    xs
  } else {
    drop (n-1) (tail xs)
  }
;

let repeat   = |x| Cons x (repeat x);
let sequence = |x| Cons x (sequence (x+1));

print (foldl (+) 0 (take 1000 (repeat 1)));   // 1000
print (foldl (+) 0 (take 1000 (sequence 1))); // 500500

let zipWith = |f xs ys|
  if or (null xs) (null ys) == True {
    Nil
  } else {
    Cons (f (head xs) (head ys)) (zipWith f (tail xs) (tail ys))
  }
;

// sequence of fibonacci numbers
let fib = Cons 0 (Cons 1 (zipWith (+) fib (tail fib)));

// print each element of list
let printList = |xs|
  if null xs == True {
    ()
  } else {
    print (head xs);
    printList (tail xs);
  }
;

// print sequence of fibonacci numbers
printList (take 10 fib);

// print 20th fibonacci number
print (head (drop 19 fib));
